<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>xchat 2.0</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@300;400;700&display=swap" rel="stylesheet">


    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the terminal-like message flow */
        #message-display {
            /* Use flex-col-reverse to make new messages appear at the bottom */
            display: flex;
            flex-direction: column-reverse;
            overflow-y: auto;
            background-color: #1f2937; /* Dark background for terminal look */
            color: #d1d5db; /* Light text color (default for others) */
            font-family: 'Roboto Condensed', sans-serif;
            font-weight: 300;
            /* REMOVED: border-radius: 0.5rem 0.5rem 0 0; for full-screen look */
            flex-grow: 1; /* Ensures it fills the available space */
            min-height: 0; /* Critical for flex items with overflow */
        }

        /* Message item styling */
        .chat-message, .system-message, .user-message {
            padding: 0.2rem 0; /* Added padding here */
            white-space: pre-wrap; /* Preserve formatting and wrap text */
            word-break: break-word; /* Ensure long words break */
            font-size: 1.1rem;
        }

        .system-message {
            color: #fca5a5; /* Red for system messages */
        }
        
        /* Color for messages sent by the current user */
        .user-message {
            color: #90caf9;
        }

        /* Customize scrollbar for a cleaner look */
        #message-display::-webkit-scrollbar {
            width: 8px;
        }

        #message-display::-webkit-scrollbar-thumb {
            background-color: #4b5563;
            border-radius: 4px;
        }

        #message-display::-webkit-scrollbar-track {
            background-color: #1f2937;
        }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }

        /** Helper function to handle Enter key press in the login fields */
        function handleLoginEnter(event) {
            if (event.key === 'Enter') {
                event.preventDefault(); // Prevent default browser action (like form submission)
                joinChat();
            }
        }
    </script>
</head>
<body class="bg-gray-100 text-gray-900 font-sans h-screen">

    <div id="app-container" class="w-full h-full relative">

        <div id="join-view" class="w-[90%] max-w-lg absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2">
            <div class="bg-gray-700 p-8 rounded-xl shadow-2xl">
                <div class="text-center mb-6 text-white font-mono text-xl">xchat 2.0</div>
                <div class="space-y-4">
                    <input id="room-input" type="text" placeholder="roomName" value=""
                        class="w-full p-3 bg-gray-600 text-gray-100 border border-gray-500 focus:outline-none focus:ring-2 focus:ring-indigo-500 placeholder-gray-400 transition duration-150"
                        onkeydown="handleLoginEnter(event)">
                    
                    <input id="user-input" type="text" placeholder="@jane, for example" value=""
                        class="w-full p-3 bg-gray-600 text-gray-100 border border-gray-500 focus:outline-none focus:ring-2 focus:ring-indigo-500 placeholder-gray-400 transition duration-150"
                        onkeydown="handleLoginEnter(event)">
                </div>
                <button id="join-button" onclick="joinChat()"
                        class="w-full mt-6 mb-6 py-3 bg-blue-500 hover:bg-indigo-500 text-white font-mono shadow-md transition duration-150 transform hover:scale-[1.01] focus:outline-none focus:ring-4 focus:ring-indigo-500/50">
                    Join
                </button>
                <p id="error-message" class="text-red-400 text-sm mt-3 text-center hidden"></p>
            </div>
        </div>

        <div id="chat-view" class="hidden w-full h-full flex flex-col bg-gray-900 overflow-hidden p-2">
            
            <div id="message-display" class="flex-grow p-4">
                </div>

            <div class="p-2 bg-gray-800 flex-shrink-0"> 
                
                <textarea id="chat-input" 
                        placeholder="type msg & hit enter..."
                        style="font-size: 1.1rem; min-height: 50px;" 
                        class="w-full p-3 bg-gray-700 text-gray-100 border border-gray-600 rounded-lg  focus:outline-none focus:ring-2 focus:ring-indigo-500 placeholder-gray-400 resize-none overflow-hidden"
                        onkeydown="handleKey(event)"
                        oninput="autoResize(this)"></textarea>
            </div>
        </div>
    </div>

    <script>
        // --- Globals ---
        let ws = null;
        let roomName = '';
        let userName = '';
        const serverHost = '192.168.1.111:30000'; // Target server location

        // --- Utility Functions ---

        /** Formats a Date object into HH:MM string using the user's local timezone. */
        const formatTimestamp = (date) => {
            return date.toLocaleTimeString([], { 
                hour: '2-digit', 
                minute: '2-digit',
                hour12: false // Use 24-hour format
            });
        };
        
        /** Adjusts the height of the textarea based on its content. */
        const autoResize = (element) => {
            // Min height set to 50px for 2 lines
            element.style.height = '50px'; 
            element.style.height = Math.max(50, element.scrollHeight) + 'px';
        };

        /** Appends a message to the display area and scrolls to the bottom. */
        const printMessage = (message, isSystem = false, isUserMessage = false) => {
            const display = document.getElementById('message-display');
            
            const msgElement = document.createElement('div');
            
            if (isSystem) {
                msgElement.className = 'system-message';
            } else if (isUserMessage) {
                msgElement.className = 'user-message';
            } else {
                msgElement.className = 'chat-message';
            }

            msgElement.textContent = message;
            
            display.prepend(msgElement); 
            display.scrollTop = 0;
        };

        /** Displays/Hides an error in the login view. */
        const displayLoginError = (msg) => {
            const errorElement = document.getElementById('error-message');
            errorElement.textContent = msg;
            errorElement.classList.remove('hidden');
        };

        const hideLoginError = () => {
            document.getElementById('error-message').classList.add('hidden');
        };

        // --- WebSocket Handlers ---

        /** Processes incoming messages from the server. */
        const handleWsMessage = (event) => {
            try {
                const incoming = JSON.parse(event.data);
                
                let displayText = '';
                let isSystem = false;
                let isUserMessage = false;

                // Helper to format text with local time (now returns an object)
                const getTimedText = (content, timeISO) => {
                    const serverTime = new Date(timeISO);
                    const localTimeStr = formatTimestamp(serverTime); 
                    return { timeStr: localTimeStr, content: content };
                };

                switch (incoming.type) {
                    case 'message':
                        // **FIXED LOGIC**: Differentiates between system and user messages for formatting
                        if (incoming.user && incoming.time && incoming.msg) {
                            const { timeStr, content } = getTimedText(incoming.msg, incoming.time);

                            isUserMessage = incoming.user === userName; 
                            isSystem = incoming.user === '@xchat';

                            if (isSystem) {
                                // SYSTEM MESSAGE FORMAT: 10:30> msg here..........
                                displayText = `${timeStr}> ${content}`;
                            } else {
                                // USER MESSAGE FORMAT: @jane 10:30> msg here..........
                                displayText = `${incoming.user} ${timeStr}> ${content}`;
                            }
                        }
                        break;
                    
                    case 'error-timed':
                        if (incoming.time && incoming.text) {
                            const timeStr = formatTimestamp(new Date(incoming.time));
                            // ERROR MESSAGE FORMAT (Using System Style): 10:30> Error msg
                            displayText = `${timeStr}> Error: ${incoming.text}`;
                            isSystem = true;
                        }
                        break;
                    
                    case 'system':
                        // Fallback system message format (without time, if time is missing)
                        displayText = `SYSTEM> ${incoming.text}`;
                        isSystem = true;
                        break;
                        
                    default:
                        const time = formatTimestamp(new Date());
                        displayText = `${time}> Unrecognized message payload received.`;
                        isSystem = true;
                        break;
                }

                if (displayText) {
                    printMessage(displayText, isSystem, isUserMessage); 
                }

            } catch (e) {
                const time = formatTimestamp(new Date());
                printMessage(`${time}> Error parsing incoming message: ${e.message}`, true);
            }
        };

        // --- Core Application Logic ---

        /** Initiates the chat connection. */
        const joinChat = () => {
            hideLoginError();
            
            const roomInput = document.getElementById('room-input').value.trim();
            let userInput = document.getElementById('user-input').value.trim(); 

            if (!roomInput || !userInput) {
                displayLoginError("Room and User names are required.");
                return;
            }
            
            // Validation logic
            if (userInput.startsWith('@')) {
                userInput = userInput.substring(1);
            }
            if (userInput.length === 0) {
                 displayLoginError("Wrong userName, please try again. The name cannot be just '@' or empty.");
                return;
            }
            
            roomName = roomInput;
            userName = `@${userInput}`; 

            const serverUrl = `ws://${serverHost}/${roomName}@${userInput}`;
            
            try {
                ws = new WebSocket(serverUrl);
            } catch (error) {
                displayLoginError(`Failed to create WebSocket: ${error.message}`);
                return;
            }

            ws.onopen = () => {
                document.getElementById('join-view').classList.add('hidden');
                document.getElementById('chat-view').classList.remove('hidden');

                const inputElement = document.getElementById('chat-input');
                autoResize(inputElement); 
            };

            ws.onmessage = handleWsMessage;

            ws.onclose = (e) => {
                const time = formatTimestamp(new Date());
                const reason = e.reason || 'server closed connection';
                printMessage(`[@xchat ${time}] connection closed. Reason: ${reason}`, true);
                
                document.getElementById('chat-view').classList.add('hidden');
                document.getElementById('join-view').classList.remove('hidden');
                ws = null;
            };

            ws.onerror = (err) => {
                const errorMessage = `Connection Failed. Ensure the WebSocket server is running at ws://${serverHost}`;
                displayLoginError(errorMessage); 
                document.getElementById('chat-view').classList.add('hidden');
                document.getElementById('join-view').classList.remove('hidden'); 
                
                console.error(`WebSocket Error: ${err.message}. ${errorMessage}`);

                if (ws && ws.readyState !== WebSocket.CLOSED) {
                    ws.close();
                }
            };
        };

        /** Sends the message in the input box. */
        const sendMessage = () => {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                const time = formatTimestamp(new Date());
                printMessage(`[@xchat ${time}] not connected. Please re-join.`, true);
                return;
            }

            const inputElement = document.getElementById('chat-input');
            const line = inputElement.value.trim();

            if (line.length > 0) {
                if (line.startsWith('/')) {
                    const parts = line.split(' ');
                    const command = parts[0].toLowerCase();
                    
                    switch (command) {
                        case '/bye':
                            ws.send(JSON.stringify(
                                {
                                    type: 'bye',
                                    text: 'good bye :-)'
                                }
                            ))
                            break;
                        case '/who':
                            ws.send(JSON.stringify({ type: 'command', command: 'who' }));
                            break;
                        default:
                            const time = formatTimestamp(new Date());
                            printMessage(`[@xchat ${time}] unknown command: ${command}`, true);
                    }
                } else {
                    ws.send(JSON.stringify({
                        type: 'chat',
                        text: line
                    }));
                }
            }
            
            inputElement.value = '';
            autoResize(inputElement); 
            
            // FIX: Remove focus to prevent mobile keyboard from reappearing.
            inputElement.blur(); 
        };

        /** Handles pressing Enter in the textarea to send the message. */
        const handleKey = (event) => {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault(); // Prevent default new line behavior
                sendMessage();
            }
        };

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('room-input').focus();
        });
    </script>
</body>
</html>