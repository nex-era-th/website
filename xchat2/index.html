<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>xchat 2.0</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@300;400;700&display=swap" rel="stylesheet">


    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the terminal-like message flow */
        #message-display {
            /* Use flex-col-reverse to make new messages appear at the bottom */
            display: flex;
            flex-direction: column-reverse;
            overflow-y: auto;
            background-color: #1f2937; /* Dark background for terminal look */
            color: #d1d5db; /* Light text color (default for others) */
            font-family: 'Roboto Condensed', sans-serif;
            font-weight: 300;
            border-radius: 0.5rem 0.5rem 0 0;
            flex-grow: 1; /* Ensures it fills the available space */
            min-height: 0; /* Critical for flex items with overflow */
        }

        /* Message item styling */
        .chat-message, .system-message, .user-message {
            padding: 0.2rem 0.5rem; /* Added padding here */
            white-space: pre-wrap; /* Preserve formatting and wrap text */
            word-break: break-word; /* Ensure long words break */
            font-size: 1.1rem;
        }

        .system-message {
            color: #fca5a5; /* Red for system messages */
        }
        
        /* Color for messages sent by the current user */
        .user-message {
            color: #90caf9;
        }

        /* Customize scrollbar for a cleaner look */
        #message-display::-webkit-scrollbar {
            width: 8px;
        }

        #message-display::-webkit-scrollbar-thumb {
            background-color: #4b5563;
            border-radius: 4px;
        }

        #message-display::-webkit-scrollbar-track {
            background-color: #1f2937;
        }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }

        /** Helper function to handle Enter key press in the login fields */
        function handleLoginEnter(event) {
            if (event.key === 'Enter') {
                event.preventDefault(); // Prevent default browser action (like form submission)
                joinChat();
            }
        }
    </script>
</head>
<body class="bg-gray-100 text-gray-900 font-sans h-screen p-2">

    <div id="app-container" class="w-full h-full mx-auto md:max-w-[600px] relative">

        <div id="join-view" class="w-full max-w-sm absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2">
            <div class="bg-gray-700 p-8 rounded-xl shadow-2xl">
                <h1 class="text-center mb-6 text-white font-mono text-xl">xchat 2.0</h1>
                <div class="space-y-4">
                    <input id="room-input" type="text" placeholder="roomName" value=""
                        class="w-full p-3 bg-gray-600 text-gray-100 border border-gray-500 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 placeholder-gray-400 transition duration-150"
                        onkeydown="handleLoginEnter(event)">
                    
                    <input id="user-input" type="text" placeholder="@jane, for example" value=""
                        class="w-full p-3 bg-gray-600 text-gray-100 border border-gray-500 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 placeholder-gray-400 transition duration-150"
                        onkeydown="handleLoginEnter(event)">
                </div>
                <button id="join-button" onclick="joinChat()"
                        class="w-full mt-6 py-3 bg-blue-500 hover:bg-indigo-500 text-white font-mono rounded-lg shadow-md transition duration-150 transform hover:scale-[1.01] focus:outline-none focus:ring-4 focus:ring-indigo-500/50">
                    Join
                </button>
                <p id="error-message" class="text-red-400 text-sm mt-3 text-center hidden"></p>
            </div>
        </div>

        <div id="chat-view" class="hidden w-full h-full flex flex-col bg-gray-900 overflow-hidden md:rounded-xl md:shadow-2xl">
            
            <div id="message-display" class="flex-grow p-4">
                </div>

            <div class="p-4 bg-gray-800 flex-shrink-0"> 
                
                <textarea id="chat-input" 
                        placeholder="type msg & hit enter..."
                        style="font-size: 1.1rem; min-height: 50px;" 
                        class="w-full p-3 bg-gray-700 text-gray-100 border border-gray-600 rounded-lg  focus:outline-none focus:ring-2 focus:ring-indigo-500 placeholder-gray-400 resize-none overflow-hidden"
                        onkeydown="handleKey(event)"
                        oninput="autoResize(this)"></textarea>
            </div>
        </div>
    </div>

    <script>
        // --- Globals ---
        let ws = null;
        let roomName = '';
        let userName = '';
        // NOTE: Make sure to update this IP address if your server changes location
        const serverHost = '192.168.1.111:30000'; // Target server location

        // --- Utility Functions ---

        /** Formats a Date object into HH:MM string using the user's local timezone. */
        const formatTimestamp = (date) => {
            // Using toLocaleTimeString with options ensures the time is formatted 
            // accurately for the user's current locale and timezone.
            return date.toLocaleTimeString([], { 
                hour: '2-digit', 
                minute: '2-digit',
                hour12: false // Use 24-hour format
            });
        };
        
        /** Adjusts the height of the textarea based on its content. */
        const autoResize = (element) => {
            // 1. Reset the height to its base (or smallest size)
            element.style.height = '50px'; // Set minimum height to 50px
            
            // 2. Set the height based on the scroll height, clamped at 50px minimum
            element.style.height = Math.max(50, element.scrollHeight) + 'px';
        };

        /** Appends a message to the display area and scrolls to the bottom. */
        const printMessage = (message, isSystem = false, isUserMessage = false) => {
            const display = document.getElementById('message-display');
            
            const msgElement = document.createElement('div');
            
            if (isSystem) {
                msgElement.className = 'system-message';
            } else if (isUserMessage) {
                msgElement.className = 'user-message';
            } else {
                msgElement.className = 'chat-message';
            }

            msgElement.textContent = message;
            
            // Using prepend() with flex-direction: column-reverse shows the newest message at the bottom.
            display.prepend(msgElement); 

            // Scroll to the logical top (scrollTop = 0) to ensure the newest message is visible.
            display.scrollTop = 0;
        };

        /** Displays an error in the login view. */
        const displayLoginError = (msg) => {
            const errorElement = document.getElementById('error-message');
            errorElement.textContent = msg;
            errorElement.classList.remove('hidden');
        };

        /** Hides the login error. */
        const hideLoginError = () => {
            document.getElementById('error-message').classList.add('hidden');
        };

        // --- WebSocket Handlers ---

        /** Processes incoming messages from the server. */
        const handleWsMessage = (event) => {
            try {
                const incoming = JSON.parse(event.data);
                
                let displayText = '';
                let isSystem = false;
                let isUserMessage = false;

                // Helper to format text with local time
                const getTimedText = (prefix, content, timeISO) => {
                    // 1. Convert ISO timestamp from server to a Date object
                    const serverTime = new Date(timeISO);
                    
                    // 2. Format the Date object using the client's local timezone
                    const localTimeStr = formatTimestamp(serverTime); 
                    
                    // 3. Reconstruct the message
                    return `${prefix} ${localTimeStr}] ${content}`;
                };

                switch (incoming.type) {
                    case 'message':
                        // Structured chat message from another user or the sender's echo
                        if (incoming.user && incoming.time && incoming.msg) {
                            displayText = getTimedText(`[${incoming.user}`, incoming.msg, incoming.time);
                            // Check if this is the message we sent (echoed back)
                            isUserMessage = incoming.user === userName; 
                        }
                        break;
                    
                    case 'system-timed':
                        // Structured system message (welcome, join/leave, /who response)
                        if (incoming.time && incoming.text) {
                            displayText = getTimedText('[@xchat', incoming.text, incoming.time);
                            isSystem = true;
                        }
                        break;

                    case 'error-timed':
                        // Structured error message
                        if (incoming.time && incoming.text) {
                            displayText = getTimedText('[@error', incoming.text, incoming.time);
                            isSystem = true;
                        }
                        break;
                    
                    case 'system':
                        // Simple system message (e.g., pre-connection errors from the server)
                        displayText = incoming.text;
                        isSystem = true;
                        break;
                        
                    default:
                        // Fallback for unknown payload
                        const time = formatTimestamp(new Date());
                        displayText = `[@xchat ${time}] Unrecognized message payload received.`;
                        isSystem = true;
                        break;
                }

                if (displayText) {
                    printMessage(displayText, isSystem, isUserMessage); 
                }

            } catch (e) {
                const time = formatTimestamp(new Date());
                printMessage(`[@xchat ${time}] Error parsing incoming message: ${e.message}`, true);
            }
        };

        /** Handles closing the connection. */
        const handleBye = () => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close(1000, 'User requested exit');
            }
        };
        
        // --- Core Application Logic ---

        /** Initiates the chat connection. */
        const joinChat = () => {
            hideLoginError();
            
            const roomInput = document.getElementById('room-input').value.trim();
            let userInput = document.getElementById('user-input').value.trim(); 

            if (!roomInput || !userInput) {
                displayLoginError("Room and User names are required.");
                return;
            }
            
            // --- USERNAME VALIDATION LOGIC ---
            
            // 1. Clean the input: Remove ONE leading '@' if present
            if (userInput.startsWith('@')) {
                userInput = userInput.substring(1);
            }

            // 2. Final check: Ensure the clean name is not empty
            if (userInput.length === 0) {
                 displayLoginError("Wrong userName, please try again. The name cannot be just '@' or empty.");
                return;
            }
            // The server will handle checks for reserved names, duplicate names, and multiple '@'s 
            // after connection is attempted, which will result in an onerror/onclose event.
            
            // --- END VALIDATION LOGIC ---

            roomName = roomInput;
            // The user's local, displayed name is always prefixed with '@'
            userName = `@${userInput}`; 

            // Build the WebSocket URL: Server expects 'roomName@userName' (no leading '@' on the name field)
            const serverUrl = `ws://${serverHost}/${roomName}@${userInput}`;
            
            try {
                ws = new WebSocket(serverUrl);
            } catch (error) {
                displayLoginError(`Failed to create WebSocket: ${error.message}`);
                return;
            }

            ws.onopen = () => {
                // Successful connection, switch views
                document.getElementById('join-view').classList.add('hidden');
                document.getElementById('chat-view').classList.remove('hidden');

                const inputElement = document.getElementById('chat-input');
                
                // Set initial height based on content
                autoResize(inputElement); 
                //inputElement.focus();
            };

            ws.onmessage = handleWsMessage;

            ws.onclose = (e) => {
                const time = formatTimestamp(new Date());
                const reason = e.reason || 'server closed connection';
                printMessage(`[@xchat ${time}] connection closed. Reason: ${reason}`, true);
                
                // Switch back to login view after closing
                document.getElementById('chat-view').classList.add('hidden');
                document.getElementById('join-view').classList.remove('hidden');
                ws = null;
            };

            ws.onerror = (err) => {
                const errorMessage = `Connection Failed. Ensure the WebSocket server is running at ws://${serverHost}`;
                
                displayLoginError(errorMessage); 

                // Immediately revert the view 
                document.getElementById('chat-view').classList.add('hidden');
                document.getElementById('join-view').classList.remove('hidden'); 
                
                console.error(`WebSocket Error: ${err.message}. ${errorMessage}`);

                if (ws && ws.readyState !== WebSocket.CLOSED) {
                    ws.close();
                }
            };
        };

        /** Sends the message in the input box. */
        const sendMessage = () => {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                const time = formatTimestamp(new Date());
                printMessage(`[@xchat ${time}] not connected. Please re-join.`, true);
                return;
            }

            const inputElement = document.getElementById('chat-input');
            const line = inputElement.value.trim();

            if (line.length > 0) {
                if (line.startsWith('/')) {
                    // Handle commands
                    const parts = line.split(' ');
                    const command = parts[0].toLowerCase();
                    
                    switch (command) {
                        case '/bye':
                            ws.send(JSON.stringify{
                                type: 'bye',
                                text: 'good bye :-)'
                            })
                            //handleBye();
                            break;
                        case '/who':
                            ws.send(JSON.stringify({ type: 'command', command: 'who' }));
                            break;
                        default:
                            const time = formatTimestamp(new Date());
                            printMessage(`[@xchat ${time}] unknown command: ${command}`, true);
                    }
                } else {
                    // Send simplified chat message payload
                    ws.send(JSON.stringify({
                        type: 'chat',
                        text: line
                    }));
                }
            }
            
            // Clear input after sending/command
            inputElement.value = '';
            
            // Resize back to minimum height after clearing the text
            autoResize(inputElement); 
            
            // Keep focus on the input for quick typing
            inputElement.blur(); 
        };

        /** Handles pressing Enter in the textarea to send the message. */
        const handleKey = (event) => {
            // Check for Shift + Enter (new line) vs Enter (send message)
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault(); // Prevent default new line behavior
                sendMessage();
            }
        };

        // --- Initialization, showing the join-view ---
        document.addEventListener('DOMContentLoaded', () => {
            // Optional: Set up focus on the first input on load
            document.getElementById('room-input').focus();
        });
    </script>
</body>
</html>