<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>xchat 2.0</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@300;400;700&display=swap" rel="stylesheet">


    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the terminal-like message flow */
        #message-display {
            /* Use flex-col-reverse to make new messages appear at the bottom */
            display: flex;
            flex-direction: column-reverse;
            overflow-y: auto;
            background-color: #1f2937; /* Dark background for terminal look */
            color: #d1d5db; /* Light text color (default for others) */
            font-family: 'Roboto Condensed', sans-serif;
            font-weight: 300;
            border-radius: 0.5rem 0.5rem 0 0;
            flex-grow: 1; /* Ensures it fills the available space */
            min-height: 0; /* Critical for flex items with overflow */
        }

        /* Message item styling */
        .chat-message, .system-message, .user-message {
            padding: 0.2rem 0;
            white-space: pre-wrap; /* Preserve formatting and wrap text */
            font-size: 1.1rem;
        }

        .system-message {
            color: #fca5a5; /* Red for system messages */
        }
        
        /* Color for messages sent by the current user */
        .user-message {
            color: #90caf9;
        }

        /* Customize scrollbar for a cleaner look */
        #message-display::-webkit-scrollbar {
            width: 8px;
        }

        #message-display::-webkit-scrollbar-thumb {
            background-color: #4b5563;
            border-radius: 4px;
        }

        #message-display::-webkit-scrollbar-track {
            background-color: #1f2937;
        }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }

        /** Helper function to handle Enter key press in the login fields */
        function handleLoginEnter(event) {
            if (event.key === 'Enter') {
                event.preventDefault(); // Prevent default browser action (like form submission)
                joinChat();
            }
        }
    </script>
</head>
<body class="bg-white text-gray-900 font-sans h-screen p-2">

    <div id="app-container" class="w-full h-full mx-auto md:max-w-[600px] relative">

        <div id="join-view" class="w-full max-w-sm absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2">
            <div class="bg-gray-700 p-8 rounded-xl shadow-2xl">
                <h1 class="text-center mb-6 text-white font-mono text-xl">xchat 2.0</h1>
                <div class="space-y-4">
                    <input id="room-input" type="text" placeholder="roomName" value=""
                        class="w-full p-3 bg-gray-600 text-gray-100 border border-gray-500 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 placeholder-gray-400 transition duration-150"
                        onkeydown="handleLoginEnter(event)">
                    
                    <input id="user-input" type="text" placeholder="@jane, for example" value=""
                        class="w-full p-3 bg-gray-600 text-gray-100 border border-gray-500 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 placeholder-gray-400 transition duration-150"
                        onkeydown="handleLoginEnter(event)">
                </div>
                <button id="join-button" onclick="joinChat()"
                        class="w-full mt-6 py-3 bg-blue-500 hover:bg-indigo-500 text-white font-mono rounded-lg shadow-md transition duration-150 transform hover:scale-[1.01] focus:outline-none focus:ring-4 focus:ring-indigo-500/50">
                    Join
                </button>
                <p id="error-message" class="text-red-400 text-sm mt-3 text-center hidden"></p>
            </div>
        </div>

        <div id="chat-view" class="hidden w-full h-full flex flex-col bg-gray-900 overflow-hidden md:rounded-xl md:shadow-2xl">
            
            <div id="message-display" class="flex-grow p-4">
                </div>

            <div class="p-4 bg-gray-800 flex-shrink-0"> 
                
                <textarea id="chat-input" 
                        placeholder="type msg & hit enter..."
                        style="font-size: 1.1rem; min-height: 50px;" 
                        class="w-full p-3 bg-gray-700 text-gray-100 border border-gray-600 rounded-t-lg  focus:outline-none focus:ring-2 focus:ring-indigo-500 placeholder-gray-400 resize-none overflow-hidden"
                        onkeydown="handleKey(event)"
                        oninput="autoResize(this)"></textarea>
            </div>
        </div>
    </div>

    <script>
        // --- Globals ---
        let ws = null;
        let roomName = '';
        let userName = '';
        // NOTE: Make sure to update this IP address if your server changes location
        const serverHost = '192.168.1.111:30000'; // Target server location

        // --- Utility Functions ---

        /** Formats a Date object into HH:MM string using the user's local timezone. */
        const formatTimestamp = (date) => {
            // Using toLocaleTimeString with options ensures the time is formatted 
            // accurately for the user's current locale and timezone.
            return date.toLocaleTimeString([], { 
                hour: '2-digit', 
                minute: '2-digit',
                hour12: false // Use 24-hour format
            });
        };
        
        /** Adjusts the height of the textarea based on its content. */
        const autoResize = (element) => {
            // 1. Reset the height to its base (or smallest size)
            element.style.height = 'auto';
            
            // 2. Set the height based on the scroll height.
            element.style.height = (element.scrollHeight) + 'px';
        };

        /** Appends a message to the display area and scrolls to the bottom. */
        const printMessage = (message, isSystem = false, isUserMessage = false) => {
            const display = document.getElementById('message-display');
            
            const msgElement = document.createElement('div');
            
            if (isSystem) {
                msgElement.className = 'system-message';
            } else if (isUserMessage) {
                msgElement.className = 'user-message';
            } else {
                msgElement.className = 'chat-message';
            }

            msgElement.textContent = message;
            
            // Using prepend() with flex-direction: column-reverse shows the newest message at the bottom.
            display.prepend(msgElement); 

            // Scroll to the logical top (scrollTop = 0) to ensure the newest message is visible.
            display.scrollTop = 0;
        };

        /** Displays an error in the login view. */
        const displayLoginError = (msg) => {
            const errorElement = document.getElementById('error-message');
            errorElement.textContent = msg;
            errorElement.classList.remove('hidden');
        };

        /** Hides the login error. */
        const hideLoginError = () => {
            document.getElementById('error-message').classList.add('hidden');
        };

        // --- WebSocket Handlers ---

        /** Processes incoming messages from the server. */
        const handleWsMessage = (event) => {
            try {
                const incoming = JSON.parse(event.data);
                
                if (incoming.text) {
                    let text = incoming.text.trim();
                    const isSystem = text.startsWith('[@xchat');
                    
                    // --- TIMESTAMP PARSING AND REPLACEMENT LOGIC ---
                    // Regex to find a pattern like "[@username 04:03]" and capture the parts
                    const timeMatch = text.match(/(\[\@[a-zA-Z0-9]+)\s(\d{2}:\d{2})(\])/);

                    if (timeMatch) {
                        const prefix = timeMatch[1]; // e.g., '[@xchat' or '[@username'
                        // Get the rest of the message content after the server's timestamp
                        const suffix = text.substring(timeMatch.index + timeMatch[0].length).trim();
                        
                        // Generate the current time in the user's local timezone
                        const localTime = formatTimestamp(new Date());

                        // Reconstruct the message with the local time
                        text = `${prefix} ${localTime}${timeMatch[3]} ${suffix}`;
                        incoming.text = text; // Update the object for printing below
                    }
                    // --- END LOGIC ---

                    // Check if the message starts with the current user's name
                    const isUserMessage = !isSystem && text.startsWith(`[${userName}`);

                    // Logic to check for /who list output would go here if needed.

                    printMessage(incoming.text, isSystem, isUserMessage); 
                } else {
                    const time = formatTimestamp(new Date());
                    printMessage(`[@xchat ${time}] unknown message format received: ${event.data}`, true);
                }
            } catch (e) {
                printMessage(`[@xchat ${formatTimestamp(new Date())}] error parsing message`, true);
            }
        };

        /** Handles closing the connection. */
        const handleBye = () => {
            if (ws && ws.readyState !== WebSocket.CLOSED) {
                ws.close(1000, 'User requested exit');
            }
        };
        
        // --- Core Application Logic ---

        /** Initiates the chat connection. */
        const joinChat = () => {
            hideLoginError();
            
            const roomInput = document.getElementById('room-input').value.trim();
            let userInput = document.getElementById('user-input').value.trim(); 

            if (!roomInput || !userInput) {
                displayLoginError("Room and User names are required.");
                return;
            }
            
            // --- USERNAME VALIDATION LOGIC ---
            
            // 1. Check for multiple '@' symbols
            const atCount = (userInput.match(/@/g) || []).length;
            
            if (atCount > 1) {
                displayLoginError("Wrong userName, please try again. Cannot contain multiple '@' symbols.");
                return;
            }
            
            // 2. Clean the input: Remove ONE leading '@' if present
            if (userInput.startsWith('@')) {
                userInput = userInput.substring(1);
            }

            // 3. Final check: Ensure the clean name is not empty
            if (userInput.length === 0) {
                 displayLoginError("Wrong userName, please try again. The name cannot be just '@' or empty.");
                return;
            }
            // --- END VALIDATION LOGIC ---

            roomName = roomInput;
            // The user's local, displayed name is always prefixed with '@'
            userName = `@${userInput}`; 

            // Build the WebSocket URL: Server expects 'roomName@userName' (no leading '@' on the name field)
            const serverUrl = `ws://${serverHost}/${roomName}@${userInput}`;
            
            try {
                ws = new WebSocket(serverUrl);
            } catch (error) {
                displayLoginError(`Failed to create WebSocket: ${error.message}`);
                return;
            }

            ws.onopen = () => {
                // Successful connection, switch views
                document.getElementById('join-view').classList.add('hidden');
                document.getElementById('chat-view').classList.remove('hidden');

                const inputElement = document.getElementById('chat-input');
                
                // Set initial height based on content (which is empty)
                autoResize(inputElement); 
            };

            ws.onmessage = handleWsMessage;

            ws.onclose = () => {
                printMessage(`[@xchat ${formatTimestamp(new Date())}] connection closed.`, true);
                
                // Switch back to login view after closing
                document.getElementById('chat-view').classList.add('hidden');
                document.getElementById('join-view').classList.remove('hidden');
                ws = null;
            };

            ws.onerror = (err) => {
                const errorMessage = `Connection Failed. Ensure the WebSocket server is running at ws://${serverHost}`;
                
                displayLoginError(errorMessage); 

                // Immediately revert the view 
                document.getElementById('chat-view').classList.add('hidden');
                document.getElementById('join-view').classList.remove('hidden'); 
                
                console.error(`WebSocket Error: ${err.message}. ${errorMessage}`);

                if (ws && ws.readyState !== WebSocket.CLOSED) {
                    ws.close();
                }
            };
        };

        /** Sends the message in the input box. */
        const sendMessage = () => {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                printMessage(`[@xchat ${formatTimestamp(new Date())}] not connected. Please re-join.`, true);
                return;
            }

            const inputElement = document.getElementById('chat-input');
            const line = inputElement.value.trim();

            if (line.length > 0) {
                if (line.startsWith('/')) {
                    // Handle commands
                    const parts = line.split(' ');
                    const command = parts[0].toLowerCase();
                    
                    switch (command) {
                        case '/bye':
                            handleBye();
                            break;
                        case '/who':
                            ws.send(JSON.stringify({ type: 'command', command: 'who' }));
                            break;
                        default:
                            printMessage(`[@xchat ${formatTimestamp(new Date())}] unknown command: ${command}`, true);
                    }
                } else {
                    // Send chat message
                    ws.send(JSON.stringify({
                        type: 'chat',
                        text: line,
                        timestamp: new Date().toISOString()
                    }));
                }
            }
            
            // Clear input after sending/command
            inputElement.value = '';
            
            // Resize back to minimum height after clearing the text
            autoResize(inputElement); 
            
            // Force the element to lose focus, preventing the mobile keyboard from reappearing.
            inputElement.blur(); 
        };

        /** Handles pressing Enter in the textarea to send the message. */
        const handleKey = (event) => {
            // Check for Shift + Enter (new line) vs Enter (send message)
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault(); // Prevent default new line behavior
                sendMessage();
            }
        };

        // --- Initialization, showing the join-view ---
        document.addEventListener('DOMContentLoaded', () => {
            // Optional: Set up focus on the first input on load
            document.getElementById('room-input').focus();
        });
    </script>
</body>
</html>